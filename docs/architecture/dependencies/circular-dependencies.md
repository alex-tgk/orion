# Circular Dependencies

**Last Updated:** Auto-generated

## Overview

This document tracks and analyzes circular dependencies in the ORION platform. Circular dependencies can lead to:

- Build issues
- Runtime errors
- Difficult-to-maintain code
- Performance problems

## Current Status

```
Status: No circular dependencies detected ✅
Last Checked: Auto-generated by CI/CD
```

## What Are Circular Dependencies?

A circular dependency occurs when Module A depends on Module B, and Module B (directly or indirectly) depends on Module A.

### Example

```typescript
// user.service.ts
import { NotificationService } from './notification.service';

export class UserService {
  constructor(private notificationService: NotificationService) {}
}

// notification.service.ts
import { UserService } from './user.service';

export class NotificationService {
  constructor(private userService: UserService) {}
}
```

This creates a circular dependency: `UserService → NotificationService → UserService`

## Detection Methods

### 1. Madge Analysis

Madge is used to detect circular dependencies in TypeScript/JavaScript code:

```bash
# Run circular dependency check
madge --circular --extensions ts packages/

# Generate visualization
madge --circular --image circular-deps.svg packages/
```

### 2. Dependency Cruiser

More sophisticated analysis with custom rules:

```bash
# Run dependency analysis
npx depcruise --config .dependency-cruiser.js packages/

# Check for circular dependencies only
npx depcruise --config .dependency-cruiser.js --validate packages/
```

### 3. TypeScript Compiler

TypeScript can detect some circular dependencies during compilation:

```bash
tsc --noEmit --extendedDiagnostics
```

## Circular Dependency Rules

### Forbidden Patterns

1. **Service-to-Service Circular References**
   ```
   ❌ AuthService → UserService → AuthService
   ```

2. **Module Circular Imports**
   ```
   ❌ Module A → Module B → Module A
   ```

3. **Cross-Package Circularity**
   ```
   ❌ @orion/auth → @orion/user → @orion/auth
   ```

### Allowed Patterns

1. **Shared Package References**
   ```
   ✅ Service → @orion/shared (one-way only)
   ```

2. **Infrastructure Dependencies**
   ```
   ✅ Service → Redis/PostgreSQL (external)
   ```

## Breaking Circular Dependencies

### Strategy 1: Dependency Inversion

**Before:**
```typescript
// user.service.ts
import { NotificationService } from './notification.service';

export class UserService {
  constructor(private notificationService: NotificationService) {}

  async createUser(data: CreateUserDto) {
    const user = await this.userRepository.create(data);
    await this.notificationService.sendWelcomeEmail(user);
    return user;
  }
}

// notification.service.ts
import { UserService } from './user.service';

export class NotificationService {
  constructor(private userService: UserService) {}

  async sendNotification(userId: string) {
    const user = await this.userService.findById(userId);
    // Send notification
  }
}
```

**After (using interfaces):**
```typescript
// interfaces/user-finder.interface.ts
export interface IUserFinder {
  findById(id: string): Promise<User>;
}

// user.service.ts
import { INotificationSender } from './interfaces/notification-sender.interface';

export class UserService implements IUserFinder {
  constructor(private notificationSender: INotificationSender) {}

  async createUser(data: CreateUserDto) {
    const user = await this.userRepository.create(data);
    await this.notificationSender.sendWelcomeEmail(user);
    return user;
  }

  async findById(id: string): Promise<User> {
    return this.userRepository.findById(id);
  }
}

// notification.service.ts
import { IUserFinder } from './interfaces/user-finder.interface';

export class NotificationService implements INotificationSender {
  constructor(private userFinder: IUserFinder) {}

  async sendNotification(userId: string) {
    const user = await this.userFinder.findById(userId);
    // Send notification
  }
}
```

### Strategy 2: Extract Common Dependencies

**Before:**
```
ModuleA → ModuleB → ModuleA
```

**After:**
```
ModuleA → SharedModule ← ModuleB
```

Example:
```typescript
// shared/interfaces/user.interface.ts
export interface User {
  id: string;
  email: string;
}

// user.service.ts
import { User } from '@orion/shared';

// notification.service.ts
import { User } from '@orion/shared';
```

### Strategy 3: Event-Driven Communication

**Before (tight coupling):**
```typescript
class UserService {
  constructor(private notificationService: NotificationService) {}

  async createUser(data: CreateUserDto) {
    const user = await this.userRepository.create(data);
    await this.notificationService.sendWelcomeEmail(user);
    return user;
  }
}
```

**After (event-driven):**
```typescript
class UserService {
  constructor(private eventEmitter: EventEmitter2) {}

  async createUser(data: CreateUserDto) {
    const user = await this.userRepository.create(data);
    this.eventEmitter.emit('user.created', user);
    return user;
  }
}

class NotificationService {
  @OnEvent('user.created')
  async handleUserCreated(user: User) {
    await this.sendWelcomeEmail(user);
  }
}
```

### Strategy 4: Message Queue Decoupling

**Before:**
```typescript
class ServiceA {
  constructor(private serviceB: ServiceB) {}

  async process() {
    await this.serviceB.doSomething();
  }
}
```

**After:**
```typescript
class ServiceA {
  constructor(private queue: Queue) {}

  async process() {
    await this.queue.add('process-task', { data });
  }
}

class ServiceB {
  @Process('process-task')
  async handleTask(job: Job) {
    // Process task
  }
}
```

## Circular Dependency Report

### Analysis Results

Run the analysis script to generate a detailed report:

```bash
npm run check:circular
```

This generates:
- List of all circular dependencies
- Dependency chain visualization
- Suggested fixes

### Example Report Format

```
Circular Dependencies Detected: 0

✓ No circular dependencies found in the codebase.

Analysis Coverage:
- Total files scanned: 247
- TypeScript files: 189
- JavaScript files: 58
- Ignored files: 1,234 (node_modules, dist, etc.)

Last updated: 2025-10-18 02:00:00
```

## Automated Detection

### Pre-commit Hook

Circular dependencies are checked before each commit:

```bash
# .husky/pre-commit
npm run check:circular
```

### CI/CD Pipeline

GitHub Actions workflow runs on every PR:

```yaml
# .github/workflows/dependency-analysis.yml
- name: Check Circular Dependencies
  run: npm run check:circular
```

### Real-time Detection

VS Code extension recommendations:
- `dependency-cruiser` extension
- `import-cost` extension

## Monitoring and Alerts

### Dashboard

View circular dependency status in Admin UI:
```
http://localhost:20004/dependencies/circular
```

### Alerts

Configure alerts for:
- New circular dependencies introduced
- Existing circular dependencies growing
- Critical circular dependencies (depth > 3)

## Best Practices

### 1. Design for Unidirectional Flow

```
Presentation Layer
      ↓
Business Logic Layer
      ↓
Data Access Layer
```

No upward dependencies allowed.

### 2. Use Dependency Injection

```typescript
@Injectable()
export class UserService {
  constructor(
    @Inject('INotificationService')
    private notificationService: INotificationService,
  ) {}
}
```

### 3. Favor Composition Over Inheritance

```typescript
// Good
class UserManager {
  constructor(
    private userRepository: UserRepository,
    private validator: UserValidator,
  ) {}
}

// Avoid
class UserManager extends BaseManager {
  // Potential for circular dependencies
}
```

### 4. Keep Services Focused

Single Responsibility Principle helps avoid circular dependencies:
- Each service has one clear purpose
- Minimal dependencies
- Clear boundaries

### 5. Use Shared Interfaces

Define interfaces in `@orion/shared`:
```typescript
// @orion/shared/interfaces/user.interface.ts
export interface IUser {
  id: string;
  email: string;
}

// Services use interface, not concrete implementation
```

## Troubleshooting

### Common Issues

**Issue:** "Cannot access X before initialization"

**Solution:** This often indicates a circular dependency. Check import order.

**Issue:** TypeScript compilation hangs

**Solution:** Likely circular dependency. Run `madge` to identify.

**Issue:** Runtime errors in dependency injection

**Solution:** Check for circular dependencies in module imports.

### Debug Commands

```bash
# Verbose circular dependency check
madge --circular --extensions ts --warning packages/

# Check specific file
madge --circular packages/user/src/user.service.ts

# Generate detailed report
madge --circular --json packages/ > circular-report.json
```

## Historical Data

Track circular dependency trends over time:

| Date | Count | Severity | Status |
|------|-------|----------|--------|
| 2025-10-18 | 0 | None | ✅ Clean |
| 2025-10-15 | 0 | None | ✅ Clean |
| 2025-10-10 | 0 | None | ✅ Clean |

## Resources

### Internal
- [Package Dependencies](./package-dependencies.md)
- [Service Dependencies](./service-dependencies.md)
- [Dependency Management Guide](../../development/dependency-management.md)

### External
- [Madge Documentation](https://github.com/pahen/madge)
- [Dependency Cruiser Documentation](https://github.com/sverweij/dependency-cruiser)
- [Circular Dependencies Explained](https://en.wikipedia.org/wiki/Circular_dependency)

## Maintenance

This document is automatically updated by:
1. `scripts/analysis/generate-dependency-graph.sh`
2. GitHub Actions workflow (on PR)
3. Manual runs: `npm run analyze:deps`

Last manual review: 2025-10-18
