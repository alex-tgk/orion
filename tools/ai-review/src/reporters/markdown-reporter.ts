import { ReviewResult } from '../types';

export class MarkdownReporter {
  generate(review: ReviewResult): string {
    let markdown = '# AI Code Review Report\n\n';

    // Summary section
    markdown += '## Summary\n\n';
    markdown += `${review.summary}\n\n`;

    // Recommendation
    markdown += '## Recommendation\n\n';
    markdown += `**${this.getRecommendationEmoji(review.recommendation)} ${review.recommendation}**\n\n`;

    // Issues by severity
    markdown += '## Issues Found\n\n';
    markdown += this.generateIssuesTable(review);

    // Detailed issues
    markdown += '\n## Detailed Findings\n\n';
    markdown += this.generateDetailedIssues(review);

    // Positive feedback
    if (review.positives && review.positives.length > 0) {
      markdown += '\n## Positive Feedback\n\n';
      for (const positive of review.positives) {
        markdown += `- ‚úÖ ${positive}\n`;
      }
      markdown += '\n';
    }

    // Metrics
    markdown += '\n## Metrics\n\n';
    markdown += this.generateMetricsTable(review);

    // Analyzer summaries
    markdown += '\n## Analyzer Results\n\n';
    markdown += this.generateAnalyzerSummaries(review);

    // Footer
    markdown += '\n---\n\n';
    markdown += `*Generated by AI Code Review Engine at ${review.timestamp}*\n`;
    markdown += '*Powered by Claude 3.5 Sonnet*\n';

    return markdown;
  }

  private getRecommendationEmoji(recommendation: string): string {
    switch (recommendation) {
      case 'APPROVE':
        return '‚úÖ';
      case 'REQUEST_CHANGES':
        return 'üî¥';
      case 'COMMENT':
        return 'üí¨';
      default:
        return '‚ùì';
    }
  }

  private generateIssuesTable(review: ReviewResult): string {
    const severities = ['critical', 'high', 'medium', 'low', 'info'];
    const counts = severities.map((s) => ({
      severity: s,
      count: review.issues.filter((i) => i.severity === s).length,
    }));

    let table = '| Severity | Count | Icon |\n';
    table += '|----------|-------|------|\n';

    const icons: Record<string, string> = {
      critical: 'üö®',
      high: '‚ö†Ô∏è',
      medium: 'üí°',
      low: 'üìù',
      info: '‚ÑπÔ∏è',
    };

    for (const { severity, count } of counts) {
      if (count > 0) {
        table += `| ${severity.charAt(0).toUpperCase() + severity.slice(1)} | ${count} | ${icons[severity]} |\n`;
      }
    }

    return table + '\n';
  }

  private generateDetailedIssues(review: ReviewResult): string {
    const groupedIssues = this.groupIssuesBySeverity(review.issues);
    let markdown = '';

    for (const [severity, issues] of Object.entries(groupedIssues)) {
      if (issues.length === 0) continue;

      const icons: Record<string, string> = {
        critical: 'üö®',
        high: '‚ö†Ô∏è',
        medium: 'üí°',
        low: 'üìù',
        info: '‚ÑπÔ∏è',
      };

      markdown += `### ${icons[severity]} ${severity.charAt(0).toUpperCase() + severity.slice(1)} Priority\n\n`;

      for (const issue of issues) {
        markdown += `#### ${issue.title || issue.type}\n\n`;
        markdown += `**File:** \`${issue.file}\``;
        if (issue.line) {
          markdown += ` (Line ${issue.line})`;
        }
        markdown += '\n\n';
        markdown += `**Category:** ${issue.category}\n\n`;
        markdown += `**Description:** ${issue.detail}\n\n`;
        markdown += `**Recommendation:** ${issue.recommendation}\n\n`;

        if (issue.suggestion) {
          markdown += `**Suggested Fix:**\n${issue.suggestion}\n\n`;
        }

        if (issue.autoFixable && issue.autoFix) {
          markdown += '**Auto-fix Available:**\n\n';
          markdown += '```typescript\n';
          markdown += issue.autoFix;
          markdown += '\n```\n\n';
        }

        markdown += '---\n\n';
      }
    }

    return markdown;
  }

  private generateMetricsTable(review: ReviewResult): string {
    let table = '| Metric | Value |\n';
    table += '|--------|-------|\n';

    if (review.metrics.complexity !== undefined) {
      table += `| Complexity | ${review.metrics.complexity}/100 |\n`;
    }
    if (review.metrics.maintainability !== undefined) {
      table += `| Maintainability | ${review.metrics.maintainability}/100 |\n`;
    }
    if (review.metrics.security !== undefined) {
      table += `| Security | ${review.metrics.security}/100 |\n`;
    }
    if (review.metrics.testCoverage !== undefined) {
      table += `| Test Coverage | ${review.metrics.testCoverage}% |\n`;
    }

    return table + '\n';
  }

  private generateAnalyzerSummaries(review: ReviewResult): string {
    let markdown = '';

    const analyzers = ['security', 'performance', 'quality', 'test', 'documentation'] as const;

    for (const analyzer of analyzers) {
      const result = review.analyzers[analyzer];
      if (!result) continue;

      markdown += `### ${analyzer.charAt(0).toUpperCase() + analyzer.slice(1)} Analysis\n\n`;
      markdown += `${result.summary}\n\n`;

      if (result.metrics) {
        markdown += '**Metrics:**\n';
        for (const [key, value] of Object.entries(result.metrics)) {
          markdown += `- ${key}: ${JSON.stringify(value)}\n`;
        }
        markdown += '\n';
      }
    }

    return markdown;
  }

  private groupIssuesBySeverity(issues: any[]): Record<string, any[]> {
    return issues.reduce(
      (acc, issue) => {
        if (!acc[issue.severity]) {
          acc[issue.severity] = [];
        }
        acc[issue.severity].push(issue);
        return acc;
      },
      {
        critical: [],
        high: [],
        medium: [],
        low: [],
        info: [],
      } as Record<string, any[]>
    );
  }
}
