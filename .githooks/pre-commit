#!/bin/bash
# Pre-commit hook - Enforces quality standards and prevents work loss

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}[Pre-commit Hook] Running quality checks...${NC}"

# Get the root directory
ROOT_DIR=$(git rev-parse --show-toplevel)

# 1. Check branch (must be on main)
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [[ "$CURRENT_BRANCH" != "main" ]] && [[ "$CURRENT_BRANCH" != "master" ]]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Warning: Not on main branch (current: $CURRENT_BRANCH)${NC}"
    echo "Consider moving to main branch for GitHub Spec Kit compliance"
fi

# 2. Auto-save work to prevent loss
BACKUP_DIR="$ROOT_DIR/.claude/backups"
mkdir -p "$BACKUP_DIR"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/pre-commit-backup-$TIMESTAMP.patch"

# Create a backup patch of staged changes
git diff --cached > "$BACKUP_FILE"
echo -e "${GREEN}‚úì Backup created: $BACKUP_FILE${NC}"

# 3. Check for spec compliance
echo -e "${BLUE}Checking spec compliance...${NC}"

# Get list of modified files
MODIFIED_FILES=$(git diff --cached --name-only)

# Check if any feature changes require a spec
HAS_FEATURE_CHANGES=false
for file in $MODIFIED_FILES; do
    # Check for source code changes (not docs or configs)
    if [[ "$file" == packages/*/src/*.ts ]] || [[ "$file" == packages/*/src/*.tsx ]]; then
        HAS_FEATURE_CHANGES=true
        break
    fi
done

if [ "$HAS_FEATURE_CHANGES" = true ]; then
    # Look for corresponding spec
    SPEC_EXISTS=false
    if [ -d "$ROOT_DIR/.specs/features" ]; then
        SPEC_COUNT=$(find "$ROOT_DIR/.specs/features" -name "*.md" -mtime -1 | wc -l)
        if [ "$SPEC_COUNT" -gt 0 ]; then
            SPEC_EXISTS=true
        fi
    fi

    if [ "$SPEC_EXISTS" = false ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Warning: Feature changes detected but no recent spec found${NC}"
        echo "Consider creating a spec: npm run spec:new <feature-name>"
    fi
fi

# 4. Run linting
echo -e "${BLUE}Running linting checks...${NC}"
if [ -f "$ROOT_DIR/package.json" ]; then
    # Check for specific packages
    for package in $MODIFIED_FILES; do
        if [[ "$package" == packages/* ]]; then
            PKG_NAME=$(echo "$package" | cut -d'/' -f2)
            if [ -d "$ROOT_DIR/packages/$PKG_NAME" ] && [ -f "$ROOT_DIR/packages/$PKG_NAME/package.json" ]; then
                echo "  Linting $PKG_NAME..."
                (cd "$ROOT_DIR" && pnpm --filter="$PKG_NAME" lint 2>/dev/null) || {
                    echo -e "${YELLOW}  ‚ö†Ô∏è  Linting issues in $PKG_NAME (non-blocking)${NC}"
                }
            fi
        fi
    done
fi

# 5. Check for debugging code
echo -e "${BLUE}Checking for debug code...${NC}"
DEBUG_PATTERNS="console\.(log|debug|trace)|debugger|TODO:|FIXME:|XXX:"

for file in $MODIFIED_FILES; do
    if [[ "$file" == *.ts ]] || [[ "$file" == *.tsx ]] || [[ "$file" == *.js ]] || [[ "$file" == *.jsx ]]; then
        if grep -E "$DEBUG_PATTERNS" "$file" > /dev/null 2>&1; then
            echo -e "${YELLOW}  ‚ö†Ô∏è  Debug code found in: $file${NC}"
            grep -n -E "$DEBUG_PATTERNS" "$file" | head -5
        fi
    fi
done

# 6. Check commit message format
COMMIT_MSG_FILE="$ROOT_DIR/.git/COMMIT_EDITMSG"
if [ -f "$COMMIT_MSG_FILE" ]; then
    COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

    # Check conventional commit format
    if ! echo "$COMMIT_MSG" | grep -qE "^(feat|fix|docs|style|refactor|perf|test|chore|spec)(\(.+\))?: .+"; then
        echo -e "${YELLOW}‚ö†Ô∏è  Commit message doesn't follow conventional format${NC}"
        echo "  Expected: <type>(<scope>): <subject>"
        echo "  Example: feat(auth): add JWT refresh token support"
    fi
fi

# 7. Check file sizes (prevent accidental large file commits)
echo -e "${BLUE}Checking file sizes...${NC}"
for file in $MODIFIED_FILES; do
    if [ -f "$file" ]; then
        FILE_SIZE=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
        if [ "$FILE_SIZE" -gt 1048576 ]; then # 1MB
            echo -e "${RED}‚ùå Large file detected: $file ($(($FILE_SIZE / 1024))KB)${NC}"
            echo "Consider using Git LFS for large files"
            exit 1
        fi
    fi
done

# 8. Update documentation
echo -e "${BLUE}Updating documentation...${NC}"
if [ -x "$ROOT_DIR/.claude/tools/doc-generator.sh" ]; then
    "$ROOT_DIR/.claude/tools/doc-generator.sh" update-silent
fi

# 9. Cache current work state
echo -e "${BLUE}Caching work state...${NC}"
CACHE_FILE="$ROOT_DIR/.claude/cache/work-state.json"
mkdir -p "$(dirname "$CACHE_FILE")"

cat > "$CACHE_FILE" << EOF
{
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "branch": "$CURRENT_BRANCH",
  "modifiedFiles": [
$(printf '    "%s"' "$MODIFIED_FILES" | sed 's/" "/",\n    "/g')
  ],
  "backupFile": "$BACKUP_FILE"
}
EOF

echo -e "${GREEN}‚úì Work state cached${NC}"

# 10. Run tests for modified packages
echo -e "${BLUE}Running tests for modified packages...${NC}"
TESTED_PACKAGES=""
for file in $MODIFIED_FILES; do
    if [[ "$file" == packages/* ]]; then
        PKG_NAME=$(echo "$file" | cut -d'/' -f2)
        if [[ ! " $TESTED_PACKAGES " =~ " $PKG_NAME " ]]; then
            if [ -d "$ROOT_DIR/packages/$PKG_NAME" ] && [ -f "$ROOT_DIR/packages/$PKG_NAME/package.json" ]; then
                echo "  Testing $PKG_NAME..."
                (cd "$ROOT_DIR" && pnpm --filter="$PKG_NAME" test 2>/dev/null) || {
                    echo -e "${YELLOW}  ‚ö†Ô∏è  Some tests failed in $PKG_NAME (non-blocking)${NC}"
                }
                TESTED_PACKAGES="$TESTED_PACKAGES $PKG_NAME"
            fi
        fi
    fi
done

# 11. Generate commit insights
INSIGHTS_FILE="$ROOT_DIR/.claude/cache/commit-insights.md"
cat > "$INSIGHTS_FILE" << EOF
# Commit Insights
**Date**: $(date)
**Branch**: $CURRENT_BRANCH
**Files Changed**: $(echo "$MODIFIED_FILES" | wc -l)

## Modified Packages
$(for file in $MODIFIED_FILES; do
    if [[ "$file" == packages/* ]]; then
        echo "$file" | cut -d'/' -f2
    fi
done | sort -u | sed 's/^/- /')

## File Types
$(for file in $MODIFIED_FILES; do
    echo "${file##*.}"
done | sort | uniq -c | awk '{print "- ." $2 ": " $1 " files"}')
EOF

echo -e "${GREEN}‚úÖ Pre-commit checks completed successfully!${NC}"
echo -e "${BLUE}üíæ Backup saved to: $BACKUP_FILE${NC}"

# Success
exit 0